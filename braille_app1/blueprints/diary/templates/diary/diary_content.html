<!-- blueprints/diary/templates/diary/diary_content.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Diary Content</title>
    <style>
        /* Existing styles... */
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #fffbe6;
            text-align: center;
        }
        #diary-content {
            width: 60%;
            height: 200px;
            padding: 10px;
            font-size: 16px;
            border: 2px solid #ccc;
            border-radius: 5px;
            margin: 20px auto;
            text-align: left;
            overflow-y: auto;
            white-space: pre-wrap;
            position: relative;
        }
        #diary-content .cursor-highlight {
            background-color: #e5e75f;
            border: 2px solid #dde74d;
            border-radius: 4px;
            padding: 2px 4px;
        }
        #status-message {
            margin-top: 20px;
            font-size: 1.2em;
            color: red;
        }
    </style>
</head>
<body>
    <h1>{{ 'Revise Diary' if revise else 'Create New Diary' }}</h1>
    
    <!-- Diary Content Display -->
    <div id="diary-content" tabindex="0" aria-label="Diary Content"></div>
    
    <!-- Status Message -->
    <div id="status-message" aria-live="polite"></div>
    
    <!-- External JavaScript -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // 1. Variable Declarations
            let cursorPosition = 0;
            let content = '';
            let diaryId = null; // If revising, the ID of the diary entry
            
            const diaryContentDiv = document.getElementById('diary-content');
            const statusMessage = document.getElementById('status-message');
            
            // Speech synthesis control
            let isSpeaking = false;

            // 2. URL Parameters Parsing
            const urlParams = new URLSearchParams(window.location.search);

            // 3. Function Definitions

            // Function to speak messages
            function speakMessage(message) {
                console.log('Speaking message:', message);
                if (isSpeaking) {
                    window.speechSynthesis.cancel();
                }
                const utterance = new SpeechSynthesisUtterance(message);
                utterance.lang = 'en-US';
                utterance.onstart = () => { isSpeaking = true; };
                utterance.onend = () => { isSpeaking = false; };
                window.speechSynthesis.speak(utterance);
                
                // Update status message
                statusMessage.textContent = message;
            }

            // Function to render the diary content with cursor highlight
            function renderContent() {
                diaryContentDiv.innerHTML = '';
                const beforeCursor = content.slice(0, cursorPosition);
                const afterCursor = content.slice(cursorPosition);
                
                const beforeNode = document.createTextNode(beforeCursor);
                const cursorSpan = document.createElement('span');
                cursorSpan.classList.add('cursor-highlight');
                cursorSpan.textContent = afterCursor.charAt(0) || '';
                const afterNode = document.createTextNode(afterCursor.slice(1));
                
                diaryContentDiv.appendChild(beforeNode);
                diaryContentDiv.appendChild(cursorSpan);
                diaryContentDiv.appendChild(afterNode);
                
                diaryContentDiv.scrollTop = diaryContentDiv.scrollHeight;
            }

            // Function to fetch existing diary content for revision
            function fetchDiaryContent(id) {
                fetch(`/diary/read/${id}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.content) {
                            content = data.content;
                            cursorPosition = content.length;
                            renderContent();
                            speakMessage('Diary loaded for revision.');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching diary content:', error);
                        speakMessage('Failed to load diary for revision.');
                    });
            }

            // Function to initialize content for creating a new diary
            function initializeContent() {
                if (!diaryId) {
                    content = '';
                    cursorPosition = 0;
                    renderContent();
                    speakMessage('Create New Diary. Start typing.');
                }
            }

            // Function to handle Braille Keyboard Signals
            function handleBrailleSignal(signal) {
                console.log('Received signal:', signal);
                switch(signal) {
                    case 'Left':
                        moveCursorLeft();
                        break;
                    case 'Right':
                        moveCursorRight();
                        break;
                    case 'Back':
                        deleteCharacter();
                        break;
                    case 'Ctrl+Backspace':
                        navigateToMenu();
                        break;
                    case 'Ctrl+Space':
                        readBeforeCursor();
                        break;
                    case 'Space':
                        insertCharacter(' ');
                        break;
                    case 'Ctrl+Enter':
                        saveDiary();
                        break;
                    default:
                        // Assume any other signal is a character input
                        insertCharacter(signal);
                }
            }

            // Function to move cursor to the left
            function moveCursorLeft() {
                if (cursorPosition > 0) {
                    cursorPosition--;
                    renderContent();
                    speakMessage(`Cursor moved to position ${cursorPosition + 1}`);
                } else {
                    speakMessage('Already at the beginning.');
                }
            }

            // Function to move cursor to the right
            function moveCursorRight() {
                if (cursorPosition < content.length) {
                    cursorPosition++;
                    renderContent();
                    speakMessage(`Cursor moved to position ${cursorPosition + 1}`);
                } else {
                    speakMessage('Already at the end.');
                }
            }

            // Function to delete character at cursor
            function deleteCharacter() {
                if (cursorPosition > 0 && content.length > 0) {
                    content = content.slice(0, cursorPosition - 1) + content.slice(cursorPosition);
                    cursorPosition--;
                    renderContent();
                    speakMessage('Character deleted.');
                } else {
                    speakMessage('Nothing to delete.');
                }
            }

            // Function to insert character at cursor
            function insertCharacter(char) {
                content = content.slice(0, cursorPosition) + char + content.slice(cursorPosition);
                cursorPosition++;
                renderContent();
                speakMessage(`Inserted ${char === ' ' ? 'space' : char}`);
            }

            // Function to read text before the cursor
            function readBeforeCursor() {
                const textToRead = content.slice(0, cursorPosition);
                if (textToRead) {
                    speakMessage(`Text before cursor: ${textToRead}`);
                } else {
                    speakMessage('No text before cursor.');
                }
            }

            // Function to navigate back to the diary menu
            function navigateToMenu() {
                speakMessage('Returning to the diary menu.');
                window.location.href = '/diary';
            }

            // Function to save the diary entry
            function saveDiary() {
                if (content.trim() === '') {
                    speakMessage('Cannot save empty diary.');
                    return;
                }
                
                const endpoint = diaryId ? `/diary/revise/${diaryId}` : `/diary/create`;
                fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ content: content }),
                })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        speakMessage(data.message);
                        window.location.href = '/diary';
                    } else if (data.error) {
                        speakMessage(data.error);
                    }
                })
                .catch(error => {
                    console.error('Error saving diary:', error);
                    speakMessage('Failed to save diary.');
                });
            }

            // Function to translate Braille bits to characters
            function translateBraille(bits) {
                // Check if the string contains the descriptive format
                if (bits.startsWith('Braille Signal (6-bit):')) {
                    // Extract the 6-bit string
                    bits = bits.split(':')[-1].trim();
                }

                const brailleDict = {
                    '000001': 'a',
                    '000011': 'b',
                    '001001': 'c',
                    '011001': 'd',
                    '010001': 'e',
                    '001011': 'f',
                    '011011': 'g',
                    '010011': 'h',
                    '001010': 'i',
                    '011010': 'j',
                    '000101': 'k',
                    '000111': 'l',
                    '001101': 'm',
                    '011101': 'n',
                    '010101': 'o',
                    '001111': 'p',
                    '011111': 'q',
                    '010111': 'r',
                    '001110': 's',
                    '011110': 't',
                    '100101': 'u',
                    '100111': 'v',
                    '110010': 'w',
                    '101101': 'x',
                    '111101': 'y',
                    '110101': 'z',
                    '000000': ' ', // Space
                };
                return brailleDict[bits] || '';
            }

            // Function to poll Braille signals from the backend
            function pollBrailleSignals() {
                console.log('Polling for Braille signals...');
                fetch('/diary/get_braille_signals')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        const brailleSignals = data.braille_signals;
                        const controlSignals = data.control_signals;
                        
                        // Handle Braille Signals (Character Inputs)
                        brailleSignals.forEach(bits => {
                            const char = translateBraille(bits);
                            if (char) {
                                console.log(`Received character: ${char}`);
                                insertCharacter(char);
                            } else {
                                console.warn(`Unrecognized Braille bits: ${bits}`);
                            }
                        });
                        
                        // Handle Control Signals
                        controlSignals.forEach(signal => {
                            handleBrailleSignal(signal);
                        });
                    })
                    .catch(error => {
                        console.error('Error polling Braille signals:', error);
                    });
            }

            // 4. Initial Function Calls

            // Determine if we're revising an existing diary entry
            if (urlParams.has('revise')) {
                diaryId = urlParams.get('revise');
                fetchDiaryContent(diaryId);
            } else {
                initializeContent();
            }

            // Start polling Braille signals every 500ms
            setInterval(pollBrailleSignals, 500);

            // Optionally, focus the diary-content div to ensure it's ready for input
            diaryContentDiv.focus();
        });
    </script>
</body>
</html>
